const puzzle = new MacApp(666, "Puzzle", true, 0, 10, 21, 89, 50, 1);
let isPressingDownPuzzle = false;

// 'puzzleBG', 88x49px
const bitmap_PuzzleBG = new Uint8Array([
	0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x22, 0x22, 0x22, 0x22, 0x22, 
	0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 
	0x55, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x50, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x27, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xf2, 0x56, 0xee, 0xee, 0xee, 0xee, 0xee, 0xee, 0xee, 0xee, 0xee, 0xe5, 0x87, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x53, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 
	0xbb, 0xbb, 0xb5, 0x27, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf2, 0x56, 0xee, 
	0xee, 0xee, 0xee, 0xee, 0xee, 0xee, 0xee, 0xee, 0xe5, 0x87, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xf0, 0x53, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xb5, 0x27, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf2, 0x56, 0xee, 0xee, 0xee, 0xee, 0xee, 
	0xee, 0xee, 0xee, 0xee, 0xe5, 0x87, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 
	0x53, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xb5, 0x27, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xf2, 0x56, 0xee, 0xee, 0xee, 0xee, 0xee, 0xee, 0xee, 0xee, 0xee, 
	0xe5, 0x87, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x53, 0xbb, 0xbb, 0xbb, 
	0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xb5, 0x27, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xf2, 0x56, 0xee, 0xee, 0xee, 0xee, 0xee, 0xee, 0xee, 0xee, 0xee, 0xe5, 0x87, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x53, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 
	0xbb, 0xbb, 0xb5, 0x27, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf2, 0x56, 0xee, 
	0xee, 0xee, 0xee, 0xee, 0xee, 0xee, 0xee, 0xee, 0xe5, 0x87, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xf0, 0x53, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xb5, 0x27, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf2, 0x56, 0xee, 0xee, 0xee, 0xee, 0xee, 
	0xee, 0xee, 0xee, 0xee, 0xe5, 0x87, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 
	0x53, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xb5, 0x27, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xf2, 0x56, 0xee, 0xee, 0xee, 0xee, 0xee, 0xee, 0xee, 0xee, 0xee, 
	0xe5, 0x87, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x53, 0xbb, 0xbb, 0xbb, 
	0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xb5, 0x27, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xf2, 0x56, 0xee, 0xee, 0xee, 0xee, 0xee, 0xee, 0xee, 0xee, 0xee, 0xe5, 0x87, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x53, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 
	0xbb, 0xbb, 0xb5, 0x27, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf2, 0x56, 0xee, 
	0xee, 0xee, 0xee, 0xee, 0xee, 0xee, 0xee, 0xee, 0xe5, 0x87, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xf0, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x22, 
	0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 
	0x55, 0x55, 0x55, 0x55, 0x55, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 
	0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55
]); 

// 'Puzzle1', 16x16px
const bitmap_Puzzle1 = new Uint8Array([
	0xff, 0xff, 0xff, 0xff, 0xff, 0x8f, 0xff, 0x2f, 0xff, 0x6f, 0xff, 0x2f, 0xff, 0xaf, 0xff, 0xaf, 
	0xff, 0xaf, 0xff, 0xaf, 0xff, 0x27, 0xff, 0x77, 0xff, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
]); 

// 'Puzzle2', 16x16px
const bitmap_Puzzle2 = new Uint8Array([
	0xff, 0xff, 0xff, 0xff, 0xfe, 0x0f, 0xfc, 0xe7, 0xfd, 0x17, 0xfc, 0x57, 0xff, 0x97, 0xff, 0x27, 
	0xfe, 0x4f, 0xfc, 0x87, 0xfd, 0x17, 0xfd, 0xf7, 0xfc, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
]); 

// 'Puzzle3', 16x16px
const bitmap_Puzzle3 = new Uint8Array([
	0xff, 0xff, 0xff, 0xff, 0xff, 0x0f, 0xfe, 0x67, 0xfe, 0x97, 0xfe, 0x17, 0xff, 0x27, 0xff, 0x67, 
	0xff, 0x13, 0xff, 0xcb, 0xff, 0xeb, 0xfc, 0x4b, 0xfd, 0x13, 0xfc, 0xe7, 0xfe, 0x0f, 0xff, 0xff
]); 

// 'Puzzle4', 16x16px
const bitmap_Puzzle4 = new Uint8Array([
	0xff, 0xff, 0xff, 0xff, 0xff, 0xc7, 0xff, 0x97, 0xff, 0x27, 0xfe, 0x47, 0xfc, 0x97, 0xfd, 0x13, 
	0xfd, 0xfb, 0xfc, 0x13, 0xff, 0x93, 0xff, 0xbb, 0xff, 0x83, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
]); 

// 'Puzzle5', 16x16px
const bitmap_Puzzle5 = new Uint8Array([
	0xff, 0xff, 0xff, 0xff, 0xfc, 0x07, 0xfd, 0xf7, 0xfd, 0x07, 0xfd, 0x0f, 0xfd, 0xe7, 0xfc, 0x13, 
	0xff, 0xcb, 0xff, 0xeb, 0xff, 0xcb, 0xff, 0x93, 0xfc, 0x27, 0xfd, 0xcf, 0xfc, 0x1f, 0xff, 0xff
]); 

// 'Puzzle6', 16x16px
const bitmap_Puzzle6 = new Uint8Array([
	0xff, 0xff, 0xff, 0x0f, 0xfe, 0x6f, 0xfc, 0x8f, 0xfd, 0x0f, 0xfd, 0x67, 0xfd, 0x93, 0xfd, 0x0b, 
	0xfd, 0x6b, 0xfd, 0x0b, 0xfc, 0x93, 0xfe, 0x67, 0xff, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
]); 

// 'Puzzle7', 16x16px
const bitmap_Puzzle7 = new Uint8Array([
	0xff, 0xff, 0xff, 0xff, 0xfc, 0x03, 0xfd, 0xfb, 0xfd, 0x0b, 0xfc, 0x53, 0xff, 0x97, 0xff, 0xa7, 
	0xff, 0x2f, 0xff, 0x4f, 0xff, 0x5f, 0xff, 0x5f, 0xff, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
]); 

function drawPuzzleNumber(x,y, number) {
	// white background
	puzzle.fillRect(x, y, 19, 19, 0);

	switch(number) {
		case 1:
			puzzle.drawBitmap(x + 1, y + 1, bitmap_Puzzle1, 16, 16);
			break;
		case 2:
			puzzle.drawBitmap(x + 1, y + 1, bitmap_Puzzle2, 16, 16);
			break;
		case 3:
			puzzle.drawBitmap(x + 1, y + 1, bitmap_Puzzle3, 16, 16);
			break;
		case 4:
			puzzle.drawBitmap(x + 1, y + 1, bitmap_Puzzle4, 16, 16);
			break;
		case 5:
			puzzle.drawBitmap(x + 1, y + 1, bitmap_Puzzle5, 16, 16);
			break;
		case 6:
			puzzle.drawBitmap(x + 1, y + 1, bitmap_Puzzle6, 16, 16);
			break;
		case 7:
			puzzle.drawBitmap(x + 1, y + 1, bitmap_Puzzle7, 16, 16);
			break;
		default:
			console.log("Trying to draw an unknown number: " + number);
			break;
	}
}

puzzle.onMouseDownInWindow = async function (x, y) {
    isPressingDownPuzzle = true;

	// check if pressing on a tile
	if (x >= 5 && y >= 5 && x < 84 && y < 45) {
		// calculate col and row of which tile
		let c = Math.floor((x - 4) / 20);
		let r = Math.floor((y - 4) / 20);

		// check we didn't click on empty tile
		if (puzzleSetup[r][c] === 0) {
			return;
		}

		// get empty tile position
		let emptyR = -1;
		let emptyC = -1;
		loop:
		for (let rr = 0; rr < 2; rr++) {
			for (let cc = 0; cc < 4; cc++) {
				if (puzzleSetup[rr][cc] === 0) {
					emptyR = rr;
					emptyC = cc;
					break loop;
				}
			}
		}

		// check if the empty tile in in this row or collumn
		if (c === emptyC || r === emptyR) {
			if (c === emptyC) { // check same collumn, we only need to swap since only 2 rows
				puzzleSetup[emptyR][emptyC] = puzzleSetup[r][c];
				puzzleSetup[r][c] = 0;
			} else { //we need to shift everything from current tile to the empty tile
				puzzleSetup[r].splice(emptyC, 1); // we remove the 0
				puzzleSetup[r].splice(c, 0, 0); // we insert it
			}

			// redraw
			drawPuzzleScreen();
		}
	}
}


puzzle.onMouseUpInWindow = function (x, y) {
    isPressingDownPuzzle = false;
}

let puzzleSetup = [
	[1, 2, 3, 4],
	[5, 6, 7, 0]
]

function drawPuzzleScreen() {
	// bg
    puzzle.drawBitmap(0,0, bitmap_PuzzleBG, 88, 49); // for this to work properly, the bitmaps width should always be a multiple of 8 (if using https://javl.github.io/image2cpp/ at least)
	
	// square frames
	puzzle.drawHLine(4, 24, 79, 1);
	puzzle.drawVLine(24, 4, 39, 1);
	puzzle.drawVLine(44, 4, 39, 1);
	puzzle.drawVLine(64, 4, 39, 1);
	
	// draw number tiles
	for (let r = 0; r < 2; r++) {
		for (let c = 0; c < 4; c++) {
			let number = puzzleSetup[r][c];
			if (number !== 0) {
				drawPuzzleNumber((c * 20) + 5, (r * 20) + 5, number);
			}
		}
	}

	setAppBackground(puzzle.id, puzzle.buffer);
}

function scramblePuzzle() {
	// start fresh
	puzzleSetup = [
		[1, 2, 3, 4],
		[5, 6, 7, 0]
	]

	let iterations = 200;
	let emptyR = 1;
	let emptyC = 3;

	for (let i = 0; i < iterations; i++) {
		let randomR = Math.floor(Math.random() * 2);
		let randomC = Math.floor(Math.random() * 4);

		if (!(randomR === emptyR && randomC === emptyC)) { // not empty tile
			// check if the empty tile in in this row or collumn
			if (randomC === emptyC || randomR === emptyR) {
				if (randomC === emptyC) { // check same collumn, we only need to swap since only 2 rows
					puzzleSetup[emptyR][emptyC] = puzzleSetup[randomR][randomC];
					puzzleSetup[randomR][randomC] = 0;
					emptyR = randomR;
					emptyC = randomC;
				} else { //we need to shift everything from current tile to the empty tile
					puzzleSetup[randomR].splice(emptyC, 1); // we remove the 0
					puzzleSetup[randomR].splice(randomC, 0, 0); // we insert it
					emptyR = randomR;
					emptyC = randomC;
				}
			}
		}
	}

}

puzzle.onInit = function () { // called when opened
	scramblePuzzle();
	drawPuzzleScreen();
}